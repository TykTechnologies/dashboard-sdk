/*
NEW Tyk DASH API

## <a name=\"introduction\"></a> Introduction      The Tyk Dashboard API offers granular, programmatic access to a centralised database of resources that your Tyk nodes can pull from. This API has a dynamic user administrative structure which means the secret key that is used to communicate with your Tyk nodes can be kept secret and access to the wider management functions can be handled on a user-by-user and organisation-by-organisation basis.      A common question around using a database-backed configuration is how to programatically add API definitions to your Tyk nodes, the Dashboard API allows much more fine-grained, secure and multi-user access to your Tyk cluster, and should be used to manage a database-backed Tyk node.      The Tyk Dashboard API works seamlessly with the Tyk Dashboard (and the two come bundled together).      ## <a name=\"security-hierarchy\"></a> Security Hierarchy      The Dashboard API provides a more structured security layer to managing Tyk nodes.      ### Organisations, APIs and Users      With the Dashboard API and a database-backed Tyk setup, (and to an extent with file-based API setups - if diligence is used in naming an creating definitions), the following security model is applied to the management of Upstream APIs:      * **Organisations**: All APIs are *owned* by an organisation, this is designated by the OrgID parameter in the API Definition.     * **Users**: All users created in the Dashboard belong to an organisation (unless an exception is made for super-administrative access).     * **APIs**: All APIs belong to an Organisation and only Users that belong to that organisation can see the analytics for those APIs and manage their configurations.     * **API Keys**: API Keys are designated by organisation, this means an API key that has full access rights will not be allowed to access the APIs of another organisation on the same system, but can have full access to all APIs within the organisation.     * **Access Rights**: Access rights are stored with the key, this enables a key to give access to multiple APIs, this is defined by the session object in the core Tyk API.      In order to use the Dashboard API, you'll need to get the Tyk Dashboard API Access Credentials secret from your user profile on the Dashboard UI.      The secret you set should then be sent along as a header with each Dashboard API Request in order for it to be successful:  authorization: <your-secret>

API version: 5.4.0
Contact: support@tyk.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type OASAPIsAPI interface {

	/*
		CreateApiOAS Create OAS API

		Create an API Definition in Tyk OAS API format.
	Note that the response includes the newly created Tyk OAS API Definition containing the unique identifier for the API (`id`). You can provide a value for `id` in the request body, otherwise Tyk will automatically generate a value.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateApiOASRequest
	*/
	CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest

	// CreateApiOASExecute executes the request
	//  @return ApiError
	CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiError, *http.Response, error)

	/*
		DeleteOASApi Delete OAS API

		Deleting an API definition will remove the file from the file store. The API definition will NOT be unloaded and a separate reload request will need to be made to disable the API endpoint.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to delete
		@return ApiDeleteOASApiRequest
	*/
	DeleteOASApi(ctx context.Context, apiId string) ApiDeleteOASApiRequest

	// DeleteOASApiExecute executes the request
	//  @return ApiError
	DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiError, *http.Response, error)

	/*
		DownloadApiOASPublic Export OAS API

		download API definition in OAS format(only APIs saved in OAS format)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to export
		@return ApiDownloadApiOASPublicRequest
	*/
	DownloadApiOASPublic(ctx context.Context, apiId string) ApiDownloadApiOASPublicRequest

	// DownloadApiOASPublicExecute executes the request
	//  @return *os.File
	DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error)

	/*
		GetApiCategories Get OAS API's Categories

		Get a list of the API categories associated with the specified API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api
		@return ApiGetApiCategoriesRequest
	*/
	GetApiCategories(ctx context.Context, apiId string) ApiGetApiCategoriesRequest

	// GetApiCategoriesExecute executes the request
	//  @return CategoriesPayload
	GetApiCategoriesExecute(r ApiGetApiCategoriesRequest) (*CategoriesPayload, *http.Response, error)

	/*
		GetOASAPIDetails Get OAS API Details

		Get a single API definition in OAS format

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to fetch
		@return ApiGetOASAPIDetailsRequest
	*/
	GetOASAPIDetails(ctx context.Context, apiId string) ApiGetOASAPIDetailsRequest

	// GetOASAPIDetailsExecute executes the request
	//  @return Schema
	GetOASAPIDetailsExecute(r ApiGetOASAPIDetailsRequest) (*Schema, *http.Response, error)

	/*
		ImportOAS Import OAS

		For use with an existing OpenAPI document that you want to expose via your Tyk Gateway.<br/> Create a new Tyk OAS API from an OpenAPI document in JSON format (without x-tyk-api-gateway extension).<br/>The payload can contain either a fully fledged OpenAPI document or a URL pointing to an OpenAPI document.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiImportOASRequest
	*/
	ImportOAS(ctx context.Context) ApiImportOASRequest

	// ImportOASExecute executes the request
	//  @return ApiError
	ImportOASExecute(r ApiImportOASRequest) (*ApiError, *http.Response, error)

	/*
		ListOASApiVersions List OAS API Versions

		List all the  versions of an OAS API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to fetch
		@return ApiListOASApiVersionsRequest
	*/
	ListOASApiVersions(ctx context.Context, apiId string) ApiListOASApiVersionsRequest

	// ListOASApiVersionsExecute executes the request
	//  @return VersionMetas
	ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error)

	/*
		PatchApiOAS Patch a single OAS API by ID

		Update an OAS format API. You can use this endpoint to update the OAS part of your Tyk API definition.This endpoint allows you to configure the Tyk OAS extension based on the query parameters provided (similar to import)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to patch
		@return ApiPatchApiOASRequest
	*/
	PatchApiOAS(ctx context.Context, apiId string) ApiPatchApiOASRequest

	// PatchApiOASExecute executes the request
	//  @return ApiError
	PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiError, *http.Response, error)

	/*
		UpdateApiCategories Update Oas Api categories

		Update the list of API categories associated with the specified API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api
		@return ApiUpdateApiCategoriesRequest
	*/
	UpdateApiCategories(ctx context.Context, apiId string) ApiUpdateApiCategoriesRequest

	// UpdateApiCategoriesExecute executes the request
	//  @return ApiError
	UpdateApiCategoriesExecute(r ApiUpdateApiCategoriesRequest) (*ApiError, *http.Response, error)

	/*
		UpdateApiOAS Update OAS API

		Updating an API definition uses the same signature object as a `POST`. It will first ensure that the API ID being updated is the same as in the `PUT` object.<br/>Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded. The hot-reload endpoint will need to be called to push the new definition to live.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the api you want to update
		@return ApiUpdateApiOASRequest
	*/
	UpdateApiOAS(ctx context.Context, apiId string) ApiUpdateApiOASRequest

	// UpdateApiOASExecute executes the request
	//  @return ApiError
	UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiError, *http.Response, error)
}

// OASAPIsAPIService OASAPIsAPI service
type OASAPIsAPIService service

type ApiCreateApiOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	templateID         *string
	schema             *Schema
}

// The base API which the new version will be linked to.
func (r ApiCreateApiOASRequest) BaseApiId(baseApiId string) ApiCreateApiOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiCreateApiOASRequest) BaseApiVersionName(baseApiVersionName string) ApiCreateApiOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiCreateApiOASRequest) NewVersionName(newVersionName string) ApiCreateApiOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiCreateApiOASRequest) SetDefault(setDefault bool) ApiCreateApiOASRequest {
	r.setDefault = &setDefault
	return r
}

// The asset ID of template to apply while creating the OAS API
func (r ApiCreateApiOASRequest) TemplateID(templateID string) ApiCreateApiOASRequest {
	r.templateID = &templateID
	return r
}

func (r ApiCreateApiOASRequest) Schema(schema Schema) ApiCreateApiOASRequest {
	r.schema = &schema
	return r
}

func (r ApiCreateApiOASRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.CreateApiOASExecute(r)
}

/*
CreateApiOAS Create OAS API

Create an API Definition in Tyk OAS API format.
Note that the response includes the newly created Tyk OAS API Definition containing the unique identifier for the API (`id`). You can provide a value for `id` in the request body, otherwise Tyk will automatically generate a value.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiOASRequest
*/
func (a *OASAPIsAPIService) CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest {
	return ApiCreateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.CreateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "")
	}
	if r.templateID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateID", r.templateID, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOASApiRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
}

func (r ApiDeleteOASApiRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.DeleteOASApiExecute(r)
}

/*
DeleteOASApi Delete OAS API

Deleting an API definition will remove the file from the file store. The API definition will NOT be unloaded and a separate reload request will need to be made to disable the API endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to delete
	@return ApiDeleteOASApiRequest
*/
func (a *OASAPIsAPIService) DeleteOASApi(ctx context.Context, apiId string) ApiDeleteOASApiRequest {
	return ApiDeleteOASApiRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DeleteOASApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApiOASPublicRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	mode       *string
}

// Mode of OAS export, by default mode could be empty which means to export OAS spec including OAS Tyk extension.When mode&#x3D;public, OAS spec excluding Tyk extension is exported
func (r ApiDownloadApiOASPublicRequest) Mode(mode string) ApiDownloadApiOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApiOASPublicRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadApiOASPublicExecute(r)
}

/*
DownloadApiOASPublic Export OAS API

download API definition in OAS format(only APIs saved in OAS format)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to export
	@return ApiDownloadApiOASPublicRequest
*/
func (a *OASAPIsAPIService) DownloadApiOASPublic(ctx context.Context, apiId string) ApiDownloadApiOASPublicRequest {
	return ApiDownloadApiOASPublicRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *OASAPIsAPIService) DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DownloadApiOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiCategoriesRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
}

func (r ApiGetApiCategoriesRequest) Execute() (*CategoriesPayload, *http.Response, error) {
	return r.ApiService.GetApiCategoriesExecute(r)
}

/*
GetApiCategories Get OAS API's Categories

Get a list of the API categories associated with the specified API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api
	@return ApiGetApiCategoriesRequest
*/
func (a *OASAPIsAPIService) GetApiCategories(ctx context.Context, apiId string) ApiGetApiCategoriesRequest {
	return ApiGetApiCategoriesRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return CategoriesPayload
func (a *OASAPIsAPIService) GetApiCategoriesExecute(r ApiGetApiCategoriesRequest) (*CategoriesPayload, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CategoriesPayload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.GetApiCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/categories"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOASAPIDetailsRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	graph      *string
}

// Transform the response payload for graphql.
func (r ApiGetOASAPIDetailsRequest) Graph(graph string) ApiGetOASAPIDetailsRequest {
	r.graph = &graph
	return r
}

func (r ApiGetOASAPIDetailsRequest) Execute() (*Schema, *http.Response, error) {
	return r.ApiService.GetOASAPIDetailsExecute(r)
}

/*
GetOASAPIDetails Get OAS API Details

Get a single API definition in OAS format

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to fetch
	@return ApiGetOASAPIDetailsRequest
*/
func (a *OASAPIsAPIService) GetOASAPIDetails(ctx context.Context, apiId string) ApiGetOASAPIDetailsRequest {
	return ApiGetOASAPIDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return Schema
func (a *OASAPIsAPIService) GetOASAPIDetailsExecute(r ApiGetOASAPIDetailsRequest) (*Schema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Schema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.GetOASAPIDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.graph != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "graph", r.graph, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	validateRequest    *bool
	mockResponse       *bool
	allowList          *bool
	authentication     *bool
	templateID         *string
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	patchApiOASRequest *PatchApiOASRequest
}

// Upstream URL for the API
func (r ApiImportOASRequest) UpstreamURL(upstreamURL string) ApiImportOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiImportOASRequest) ListenPath(listenPath string) ApiImportOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiImportOASRequest) CustomDomain(customDomain string) ApiImportOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiImportOASRequest) ValidateRequest(validateRequest bool) ApiImportOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiImportOASRequest) MockResponse(mockResponse bool) ApiImportOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiImportOASRequest) AllowList(allowList bool) ApiImportOASRequest {
	r.allowList = &allowList
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API
func (r ApiImportOASRequest) Authentication(authentication bool) ApiImportOASRequest {
	r.authentication = &authentication
	return r
}

// The asset ID of template to apply while importing an OAS API.
func (r ApiImportOASRequest) TemplateID(templateID string) ApiImportOASRequest {
	r.templateID = &templateID
	return r
}

// The base API which the new version will be linked to.
func (r ApiImportOASRequest) BaseApiId(baseApiId string) ApiImportOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiImportOASRequest) BaseApiVersionName(baseApiVersionName string) ApiImportOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiImportOASRequest) NewVersionName(newVersionName string) ApiImportOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiImportOASRequest) SetDefault(setDefault bool) ApiImportOASRequest {
	r.setDefault = &setDefault
	return r
}

// The content of the file should be the OpenAPI document in JSON format (without x-tyk-api-gateway extension).
func (r ApiImportOASRequest) PatchApiOASRequest(patchApiOASRequest PatchApiOASRequest) ApiImportOASRequest {
	r.patchApiOASRequest = &patchApiOASRequest
	return r
}

func (r ApiImportOASRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.ImportOASExecute(r)
}

/*
ImportOAS Import OAS

For use with an existing OpenAPI document that you want to expose via your Tyk Gateway.<br/> Create a new Tyk OAS API from an OpenAPI document in JSON format (without x-tyk-api-gateway extension).<br/>The payload can contain either a fully fledged OpenAPI document or a URL pointing to an OpenAPI document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImportOASRequest
*/
func (a *OASAPIsAPIService) ImportOAS(ctx context.Context) ApiImportOASRequest {
	return ApiImportOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) ImportOASExecute(r ApiImportOASRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ImportOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "")
	}
	if r.templateID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateID", r.templateID, "")
	}
	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchApiOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOASApiVersionsRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	searchText *string
	accessType *string
}

// Search for API version name
func (r ApiListOASApiVersionsRequest) SearchText(searchText string) ApiListOASApiVersionsRequest {
	r.searchText = &searchText
	return r
}

// Filter for internal or external API versions
func (r ApiListOASApiVersionsRequest) AccessType(accessType string) ApiListOASApiVersionsRequest {
	r.accessType = &accessType
	return r
}

func (r ApiListOASApiVersionsRequest) Execute() (*VersionMetas, *http.Response, error) {
	return r.ApiService.ListOASApiVersionsExecute(r)
}

/*
ListOASApiVersions List OAS API Versions

List all the  versions of an OAS API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to fetch
	@return ApiListOASApiVersionsRequest
*/
func (a *OASAPIsAPIService) ListOASApiVersions(ctx context.Context, apiId string) ApiListOASApiVersionsRequest {
	return ApiListOASApiVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return VersionMetas
func (a *OASAPIsAPIService) ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VersionMetas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ListOASApiVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "")
	}
	if r.accessType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessType", r.accessType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	apiId              string
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	validateRequest    *bool
	mockResponse       *bool
	allowList          *bool
	authentication     *bool
	patchApiOASRequest *PatchApiOASRequest
}

// Upstream URL for the API
func (r ApiPatchApiOASRequest) UpstreamURL(upstreamURL string) ApiPatchApiOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API
func (r ApiPatchApiOASRequest) ListenPath(listenPath string) ApiPatchApiOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API
func (r ApiPatchApiOASRequest) CustomDomain(customDomain string) ApiPatchApiOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json
func (r ApiPatchApiOASRequest) ValidateRequest(validateRequest bool) ApiPatchApiOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiPatchApiOASRequest) MockResponse(mockResponse bool) ApiPatchApiOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable allowList middleware for all endpoints
func (r ApiPatchApiOASRequest) AllowList(allowList bool) ApiPatchApiOASRequest {
	r.allowList = &allowList
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API
func (r ApiPatchApiOASRequest) Authentication(authentication bool) ApiPatchApiOASRequest {
	r.authentication = &authentication
	return r
}

// The content of the file should be the OpenAPI document in JSON format (without x-tyk-api-gateway extension).
func (r ApiPatchApiOASRequest) PatchApiOASRequest(patchApiOASRequest PatchApiOASRequest) ApiPatchApiOASRequest {
	r.patchApiOASRequest = &patchApiOASRequest
	return r
}

func (r ApiPatchApiOASRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.PatchApiOASExecute(r)
}

/*
PatchApiOAS Patch a single OAS API by ID

Update an OAS format API. You can use this endpoint to update the OAS part of your Tyk API definition.This endpoint allows you to configure the Tyk OAS extension based on the query parameters provided (similar to import)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to patch
	@return ApiPatchApiOASRequest
*/
func (a *OASAPIsAPIService) PatchApiOAS(ctx context.Context, apiId string) ApiPatchApiOASRequest {
	return ApiPatchApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.PatchApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchApiOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiCategoriesRequest struct {
	ctx               context.Context
	ApiService        OASAPIsAPI
	apiId             string
	categoriesPayload *CategoriesPayload
}

func (r ApiUpdateApiCategoriesRequest) CategoriesPayload(categoriesPayload CategoriesPayload) ApiUpdateApiCategoriesRequest {
	r.categoriesPayload = &categoriesPayload
	return r
}

func (r ApiUpdateApiCategoriesRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.UpdateApiCategoriesExecute(r)
}

/*
UpdateApiCategories Update Oas Api categories

Update the list of API categories associated with the specified API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api
	@return ApiUpdateApiCategoriesRequest
*/
func (a *OASAPIsAPIService) UpdateApiCategories(ctx context.Context, apiId string) ApiUpdateApiCategoriesRequest {
	return ApiUpdateApiCategoriesRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) UpdateApiCategoriesExecute(r ApiUpdateApiCategoriesRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.UpdateApiCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/categories"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.categoriesPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiOASRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	schema     *Schema
}

func (r ApiUpdateApiOASRequest) Schema(schema Schema) ApiUpdateApiOASRequest {
	r.schema = &schema
	return r
}

func (r ApiUpdateApiOASRequest) Execute() (*ApiError, *http.Response, error) {
	return r.ApiService.UpdateApiOASExecute(r)
}

/*
UpdateApiOAS Update OAS API

Updating an API definition uses the same signature object as a `POST`. It will first ensure that the API ID being updated is the same as in the `PUT` object.<br/>Updating will completely replace the file descriptor and will not change an API Definition that has already been loaded. The hot-reload endpoint will need to be called to push the new definition to live.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the api you want to update
	@return ApiUpdateApiOASRequest
*/
func (a *OASAPIsAPIService) UpdateApiOAS(ctx context.Context, apiId string) ApiUpdateApiOASRequest {
	return ApiUpdateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiError
func (a *OASAPIsAPIService) UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiError, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiError
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.UpdateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.schema
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
