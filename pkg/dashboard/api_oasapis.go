/*
Tyk Dashboard API

 ## <a name=\"introduction\"></a> Introduction  The Tyk Dashboard API offers granular, programmatic access to a centralised database of resources that your Tyk nodes can pull from. This API has a dynamic user administrative structure which means the secret key that is used to communicate with your Tyk nodes can be kept secret and access to the wider management functions can be handled on a user-by-user and organisation-by-organisation basis.  A common question around using a database-backed configuration is how to programmatically add API definitions to your Tyk nodes, the Dashboard API allows much more fine-grained, secure and multi-user access to your Tyk cluster, and should be used to manage a database-backed Tyk node.  The Tyk Dashboard API works seamlessly with the Tyk Dashboard (and the two come bundled together).  ## <a name=\"security-hierarchy\"></a> Security Hierarchy  The Dashboard API provides a more structured security layer to managing Tyk nodes.  ### Organisations, APIs and Users  With the Dashboard API and a database-backed Tyk setup, (and to an extent with file-based API setups - if diligence is used in naming and creating definitions), the following security model is applied to the management of Upstream APIs:  * **Organisations**: All APIs are *owned* by an organisation, this is designated by the 'OrgID' parameter in the API Definition. * **Users**: All users created in the Dashboard belong to an organisation (unless an exception is made for super-administrative access). * **APIs**: All APIs belong to an Organisation and only Users that belong to that organisation can see the analytics for those APIs and manage their configurations. * **API Keys**: API Keys are designated by organisation, this means an API key that has full access rights will not be allowed to access the APIs of another organisation on the same system, but can have full access to all APIs within the organisation. * **Access Rights**: Access rights are stored with the key, this enables a key to give access to multiple APIs, this is defined by the session object in the core Tyk API.  In order to use the Dashboard API, you'll need to get the 'Tyk Dashboard API Access Credentials' secret from your user profile on the Dashboard UI.  The secret you set should then be sent along as a header with each Dashboard API Request in order for it to be successful:   authorization: <your-secret>

API version: 5.6.0
Contact: support@tyk.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type OASAPIsAPI interface {

	/*
		CreateApiOAS Create OAS API.

		Create an API Definition in Tyk OAS API format.
	 Note that the response includes the newly created Tyk OAS API Definition containing the unique identifier for the API (`ID`). You can provide a value for `ID` in the request body, otherwise Tyk will automatically generate a value.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateApiOASRequest
	*/
	CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest

	// CreateApiOASExecute executes the request
	//  @return ApiResponse
	CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiResponse, *http.Response, error)

	/*
		DeleteOASApi Delete OAS API.

		Deleting an API definition will remove the file from the file store. The API definition will not be unloaded and a separate reload request will need to be made to disable the API endpoint.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to delete.
		@return ApiDeleteOASApiRequest
	*/
	DeleteOASApi(ctx context.Context, apiId string) ApiDeleteOASApiRequest

	// DeleteOASApiExecute executes the request
	//  @return ApiResponse
	DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiResponse, *http.Response, error)

	/*
		DownloadApiOASPublic Export OAS API.

		Download API definition in OAS format (only APIs saved in OAS format). When you set the mode query parameter to public the OAS spec exported will exclude the x-tyk-api-gateway part. When mode query parameter is empty or is set to any other value apart from public then the exported OAS spec will include the x-tyk-api-gateway part.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to export.
		@return ApiDownloadApiOASPublicRequest
	*/
	DownloadApiOASPublic(ctx context.Context, apiId string) ApiDownloadApiOASPublicRequest

	// DownloadApiOASPublicExecute executes the request
	//  @return *os.File
	DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error)

	/*
		DryRunApiOAS Dry Run OAS.

		Generate a Tyk OAS API definition without saving it to the Dashboard database.
	This endpoint is used to produce a Tyk OAS API definition without creating the API proxy itself. This provides a dry run functionality for Tyk OAS API creation, showing what would be created in the Dashboard given the set of inputs provided.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiDryRunApiOASRequest
	*/
	DryRunApiOAS(ctx context.Context) ApiDryRunApiOASRequest

	// DryRunApiOASExecute executes the request
	//  @return DryRunApiOAS200Response
	DryRunApiOASExecute(r ApiDryRunApiOASRequest) (*DryRunApiOAS200Response, *http.Response, error)

	/*
		GetApiCategories Get OAS API's Categories.

		Get a list of the API categories associated with the specified API.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API.
		@return ApiGetApiCategoriesRequest
	*/
	GetApiCategories(ctx context.Context, apiId string) ApiGetApiCategoriesRequest

	// GetApiCategoriesExecute executes the request
	//  @return CategoriesPayload
	GetApiCategoriesExecute(r ApiGetApiCategoriesRequest) (*CategoriesPayload, *http.Response, error)

	/*
		GetOASAPIDetails Get OAS API details.

		Get a single API definition in OAS format.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to fetch.
		@return ApiGetOASAPIDetailsRequest
	*/
	GetOASAPIDetails(ctx context.Context, apiId string) ApiGetOASAPIDetailsRequest

	// GetOASAPIDetailsExecute executes the request
	//  @return CreateApiOASRequest
	GetOASAPIDetailsExecute(r ApiGetOASAPIDetailsRequest) (*CreateApiOASRequest, *http.Response, error)

	/*
		ImportOAS Import OAS.

		For use with an existing OpenAPI document that you want to expose via your Tyk Gateway. <br/> Create a new Tyk OAS API from an OpenAPI document in JSON format (without x-tyk-api-gateway extension). <br/>The payload can contain either a fully fledged OpenAPI document or a URL pointing to an OpenAPI document.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiImportOASRequest
	*/
	ImportOAS(ctx context.Context) ApiImportOASRequest

	// ImportOASExecute executes the request
	//  @return ApiResponse
	ImportOASExecute(r ApiImportOASRequest) (*ApiResponse, *http.Response, error)

	/*
		ListOASApiVersions List OAS API versions.

		List all the  versions of an OAS API.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to fetch.
		@return ApiListOASApiVersionsRequest
	*/
	ListOASApiVersions(ctx context.Context, apiId string) ApiListOASApiVersionsRequest

	// ListOASApiVersionsExecute executes the request
	//  @return VersionMetas
	ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error)

	/*
		PatchApiOAS Patch a single OAS API by ID.

		Update a Tyk OAS API. You can use this endpoint to update the OAS part of your Tyk OAS API definition. This endpoint allows you to configure the Tyk OAS extension based on the query parameters provided (similar to import).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to patch.
		@return ApiPatchApiOASRequest
	*/
	PatchApiOAS(ctx context.Context, apiId string) ApiPatchApiOASRequest

	// PatchApiOASExecute executes the request
	//  @return ApiResponse
	PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiResponse, *http.Response, error)

	/*
		UpdateApiCategories Update OAS API categories.

		Update the list of API categories associated with the specified API.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API.
		@return ApiUpdateApiCategoriesRequest
	*/
	UpdateApiCategories(ctx context.Context, apiId string) ApiUpdateApiCategoriesRequest

	// UpdateApiCategoriesExecute executes the request
	//  @return ApiResponse
	UpdateApiCategoriesExecute(r ApiUpdateApiCategoriesRequest) (*ApiResponse, *http.Response, error)

	/*
		UpdateApiOAS Update OAS API.

		Updating an API definition uses the same signature object as a `POST`. It will first ensure that the API ID being updated is the same as in the `PUT` object.<br/> Updating will completely replace the file descriptor and will not change an API definition that has already been loaded. The hot-reload endpoint will need to be called to push the new definition to live.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param apiId ID of the API you want to update.
		@return ApiUpdateApiOASRequest
	*/
	UpdateApiOAS(ctx context.Context, apiId string) ApiUpdateApiOASRequest

	// UpdateApiOASExecute executes the request
	//  @return ApiResponse
	UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiResponse, *http.Response, error)
}

// OASAPIsAPIService OASAPIsAPI service
type OASAPIsAPIService service

type ApiCreateApiOASRequest struct {
	ctx                 context.Context
	ApiService          OASAPIsAPI
	baseApiId           *string
	baseApiVersionName  *string
	newVersionName      *string
	setDefault          *bool
	templateID          *string
	createApiOASRequest *CreateApiOASRequest
}

// The base API which the new version will be linked to.
func (r ApiCreateApiOASRequest) BaseApiId(baseApiId string) ApiCreateApiOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiCreateApiOASRequest) BaseApiVersionName(baseApiVersionName string) ApiCreateApiOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiCreateApiOASRequest) NewVersionName(newVersionName string) ApiCreateApiOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiCreateApiOASRequest) SetDefault(setDefault bool) ApiCreateApiOASRequest {
	r.setDefault = &setDefault
	return r
}

// The Asset ID of template applied while creating or importing an OAS API.
func (r ApiCreateApiOASRequest) TemplateID(templateID string) ApiCreateApiOASRequest {
	r.templateID = &templateID
	return r
}

func (r ApiCreateApiOASRequest) CreateApiOASRequest(createApiOASRequest CreateApiOASRequest) ApiCreateApiOASRequest {
	r.createApiOASRequest = &createApiOASRequest
	return r
}

func (r ApiCreateApiOASRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.CreateApiOASExecute(r)
}

/*
CreateApiOAS Create OAS API.

Create an API Definition in Tyk OAS API format.

	Note that the response includes the newly created Tyk OAS API Definition containing the unique identifier for the API (`ID`). You can provide a value for `ID` in the request body, otherwise Tyk will automatically generate a value.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiOASRequest
*/
func (a *OASAPIsAPIService) CreateApiOAS(ctx context.Context) ApiCreateApiOASRequest {
	return ApiCreateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) CreateApiOASExecute(r ApiCreateApiOASRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.CreateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "form", "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "form", "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "form", "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "form", "")
	}
	if r.templateID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateID", r.templateID, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApiOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOASApiRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
}

func (r ApiDeleteOASApiRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.DeleteOASApiExecute(r)
}

/*
DeleteOASApi Delete OAS API.

Deleting an API definition will remove the file from the file store. The API definition will not be unloaded and a separate reload request will need to be made to disable the API endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to delete.
	@return ApiDeleteOASApiRequest
*/
func (a *OASAPIsAPIService) DeleteOASApi(ctx context.Context, apiId string) ApiDeleteOASApiRequest {
	return ApiDeleteOASApiRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) DeleteOASApiExecute(r ApiDeleteOASApiRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DeleteOASApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadApiOASPublicRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	mode       *string
}

// Mode of OAS export, by default mode could be empty which means to export OAS spec including OAS Tyk extension. When mode&#x3D;public, OAS spec excluding Tyk extension is exported.
func (r ApiDownloadApiOASPublicRequest) Mode(mode string) ApiDownloadApiOASPublicRequest {
	r.mode = &mode
	return r
}

func (r ApiDownloadApiOASPublicRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadApiOASPublicExecute(r)
}

/*
DownloadApiOASPublic Export OAS API.

Download API definition in OAS format (only APIs saved in OAS format). When you set the mode query parameter to public the OAS spec exported will exclude the x-tyk-api-gateway part. When mode query parameter is empty or is set to any other value apart from public then the exported OAS spec will include the x-tyk-api-gateway part.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to export.
	@return ApiDownloadApiOASPublicRequest
*/
func (a *OASAPIsAPIService) DownloadApiOASPublic(ctx context.Context, apiId string) ApiDownloadApiOASPublicRequest {
	return ApiDownloadApiOASPublicRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *OASAPIsAPIService) DownloadApiOASPublicExecute(r ApiDownloadApiOASPublicRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DownloadApiOASPublic")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mode", r.mode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDryRunApiOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	templateID         *string
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	allowList          *bool
	validateRequest    *bool
	mockResponse       *bool
	authentication     *bool
	dryRunRequest      *DryRunRequest
}

// The Asset ID of template applied while creating or importing an OAS API.
func (r ApiDryRunApiOASRequest) TemplateID(templateID string) ApiDryRunApiOASRequest {
	r.templateID = &templateID
	return r
}

// The base API which the new version will be linked to.
func (r ApiDryRunApiOASRequest) BaseApiId(baseApiId string) ApiDryRunApiOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiDryRunApiOASRequest) BaseApiVersionName(baseApiVersionName string) ApiDryRunApiOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiDryRunApiOASRequest) NewVersionName(newVersionName string) ApiDryRunApiOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiDryRunApiOASRequest) SetDefault(setDefault bool) ApiDryRunApiOASRequest {
	r.setDefault = &setDefault
	return r
}

// Upstream URL for the API.
func (r ApiDryRunApiOASRequest) UpstreamURL(upstreamURL string) ApiDryRunApiOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API.
func (r ApiDryRunApiOASRequest) ListenPath(listenPath string) ApiDryRunApiOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API.
func (r ApiDryRunApiOASRequest) CustomDomain(customDomain string) ApiDryRunApiOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable allowList middleware for all endpoints.
func (r ApiDryRunApiOASRequest) AllowList(allowList bool) ApiDryRunApiOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json.
func (r ApiDryRunApiOASRequest) ValidateRequest(validateRequest bool) ApiDryRunApiOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiDryRunApiOASRequest) MockResponse(mockResponse bool) ApiDryRunApiOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API.
func (r ApiDryRunApiOASRequest) Authentication(authentication bool) ApiDryRunApiOASRequest {
	r.authentication = &authentication
	return r
}

func (r ApiDryRunApiOASRequest) DryRunRequest(dryRunRequest DryRunRequest) ApiDryRunApiOASRequest {
	r.dryRunRequest = &dryRunRequest
	return r
}

func (r ApiDryRunApiOASRequest) Execute() (*DryRunApiOAS200Response, *http.Response, error) {
	return r.ApiService.DryRunApiOASExecute(r)
}

/*
DryRunApiOAS Dry Run OAS.

Generate a Tyk OAS API definition without saving it to the Dashboard database.
This endpoint is used to produce a Tyk OAS API definition without creating the API proxy itself. This provides a dry run functionality for Tyk OAS API creation, showing what would be created in the Dashboard given the set of inputs provided.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDryRunApiOASRequest
*/
func (a *OASAPIsAPIService) DryRunApiOAS(ctx context.Context) ApiDryRunApiOASRequest {
	return ApiDryRunApiOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DryRunApiOAS200Response
func (a *OASAPIsAPIService) DryRunApiOASExecute(r ApiDryRunApiOASRequest) (*DryRunApiOAS200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DryRunApiOAS200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.DryRunApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/dry-run"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.templateID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateID", r.templateID, "form", "")
	}
	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "form", "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "form", "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "form", "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "form", "")
	}
	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "form", "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "form", "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "form", "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "form", "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "form", "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "form", "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dryRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiCategoriesRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
}

func (r ApiGetApiCategoriesRequest) Execute() (*CategoriesPayload, *http.Response, error) {
	return r.ApiService.GetApiCategoriesExecute(r)
}

/*
GetApiCategories Get OAS API's Categories.

Get a list of the API categories associated with the specified API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API.
	@return ApiGetApiCategoriesRequest
*/
func (a *OASAPIsAPIService) GetApiCategories(ctx context.Context, apiId string) ApiGetApiCategoriesRequest {
	return ApiGetApiCategoriesRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return CategoriesPayload
func (a *OASAPIsAPIService) GetApiCategoriesExecute(r ApiGetApiCategoriesRequest) (*CategoriesPayload, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CategoriesPayload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.GetApiCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/categories"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOASAPIDetailsRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
}

func (r ApiGetOASAPIDetailsRequest) Execute() (*CreateApiOASRequest, *http.Response, error) {
	return r.ApiService.GetOASAPIDetailsExecute(r)
}

/*
GetOASAPIDetails Get OAS API details.

Get a single API definition in OAS format.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to fetch.
	@return ApiGetOASAPIDetailsRequest
*/
func (a *OASAPIsAPIService) GetOASAPIDetails(ctx context.Context, apiId string) ApiGetOASAPIDetailsRequest {
	return ApiGetOASAPIDetailsRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return CreateApiOASRequest
func (a *OASAPIsAPIService) GetOASAPIDetailsExecute(r ApiGetOASAPIDetailsRequest) (*CreateApiOASRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateApiOASRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.GetOASAPIDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	allowList          *bool
	validateRequest    *bool
	mockResponse       *bool
	authentication     *bool
	templateID         *string
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	importOASRequest   *ImportOASRequest
}

// Upstream URL for the API.
func (r ApiImportOASRequest) UpstreamURL(upstreamURL string) ApiImportOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API.
func (r ApiImportOASRequest) ListenPath(listenPath string) ApiImportOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API.
func (r ApiImportOASRequest) CustomDomain(customDomain string) ApiImportOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable allowList middleware for all endpoints.
func (r ApiImportOASRequest) AllowList(allowList bool) ApiImportOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json.
func (r ApiImportOASRequest) ValidateRequest(validateRequest bool) ApiImportOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiImportOASRequest) MockResponse(mockResponse bool) ApiImportOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API.
func (r ApiImportOASRequest) Authentication(authentication bool) ApiImportOASRequest {
	r.authentication = &authentication
	return r
}

// The Asset ID of template applied while creating or importing an OAS API.
func (r ApiImportOASRequest) TemplateID(templateID string) ApiImportOASRequest {
	r.templateID = &templateID
	return r
}

// The base API which the new version will be linked to.
func (r ApiImportOASRequest) BaseApiId(baseApiId string) ApiImportOASRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiImportOASRequest) BaseApiVersionName(baseApiVersionName string) ApiImportOASRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiImportOASRequest) NewVersionName(newVersionName string) ApiImportOASRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiImportOASRequest) SetDefault(setDefault bool) ApiImportOASRequest {
	r.setDefault = &setDefault
	return r
}

// The content of the file should be the OpenAPI document in JSON format (without x-tyk-api-gateway extension).
func (r ApiImportOASRequest) ImportOASRequest(importOASRequest ImportOASRequest) ApiImportOASRequest {
	r.importOASRequest = &importOASRequest
	return r
}

func (r ApiImportOASRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ImportOASExecute(r)
}

/*
ImportOAS Import OAS.

For use with an existing OpenAPI document that you want to expose via your Tyk Gateway. <br/> Create a new Tyk OAS API from an OpenAPI document in JSON format (without x-tyk-api-gateway extension). <br/>The payload can contain either a fully fledged OpenAPI document or a URL pointing to an OpenAPI document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImportOASRequest
*/
func (a *OASAPIsAPIService) ImportOAS(ctx context.Context) ApiImportOASRequest {
	return ApiImportOASRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) ImportOASExecute(r ApiImportOASRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ImportOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "form", "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "form", "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "form", "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "form", "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "form", "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "form", "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "form", "")
	}
	if r.templateID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "templateID", r.templateID, "form", "")
	}
	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "form", "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "form", "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "form", "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOASApiVersionsRequest struct {
	ctx        context.Context
	ApiService OASAPIsAPI
	apiId      string
	searchText *string
	accessType *string
}

// Search for API version name.
func (r ApiListOASApiVersionsRequest) SearchText(searchText string) ApiListOASApiVersionsRequest {
	r.searchText = &searchText
	return r
}

// Filter for internal or external API versions.
func (r ApiListOASApiVersionsRequest) AccessType(accessType string) ApiListOASApiVersionsRequest {
	r.accessType = &accessType
	return r
}

func (r ApiListOASApiVersionsRequest) Execute() (*VersionMetas, *http.Response, error) {
	return r.ApiService.ListOASApiVersionsExecute(r)
}

/*
ListOASApiVersions List OAS API versions.

List all the  versions of an OAS API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to fetch.
	@return ApiListOASApiVersionsRequest
*/
func (a *OASAPIsAPIService) ListOASApiVersions(ctx context.Context, apiId string) ApiListOASApiVersionsRequest {
	return ApiListOASApiVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return VersionMetas
func (a *OASAPIsAPIService) ListOASApiVersionsExecute(r ApiListOASApiVersionsRequest) (*VersionMetas, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VersionMetas
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.ListOASApiVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.searchText != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchText", r.searchText, "form", "")
	}
	if r.accessType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accessType", r.accessType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchApiOASRequest struct {
	ctx                context.Context
	ApiService         OASAPIsAPI
	apiId              string
	upstreamURL        *string
	listenPath         *string
	customDomain       *string
	allowList          *bool
	validateRequest    *bool
	mockResponse       *bool
	authentication     *bool
	patchApiOASRequest *PatchApiOASRequest
}

// Upstream URL for the API.
func (r ApiPatchApiOASRequest) UpstreamURL(upstreamURL string) ApiPatchApiOASRequest {
	r.upstreamURL = &upstreamURL
	return r
}

// Listen path for the API.
func (r ApiPatchApiOASRequest) ListenPath(listenPath string) ApiPatchApiOASRequest {
	r.listenPath = &listenPath
	return r
}

// Custom domain for the API.
func (r ApiPatchApiOASRequest) CustomDomain(customDomain string) ApiPatchApiOASRequest {
	r.customDomain = &customDomain
	return r
}

// Enable allowList middleware for all endpoints.
func (r ApiPatchApiOASRequest) AllowList(allowList bool) ApiPatchApiOASRequest {
	r.allowList = &allowList
	return r
}

// Enable validateRequest middleware for all endpoints having a request body with media type application/json.
func (r ApiPatchApiOASRequest) ValidateRequest(validateRequest bool) ApiPatchApiOASRequest {
	r.validateRequest = &validateRequest
	return r
}

// Enable mockResponse middleware for all endpoints having responses configured.
func (r ApiPatchApiOASRequest) MockResponse(mockResponse bool) ApiPatchApiOASRequest {
	r.mockResponse = &mockResponse
	return r
}

// Enable/disable the authentication mechanism in your Tyk Gateway for your OAS API.
func (r ApiPatchApiOASRequest) Authentication(authentication bool) ApiPatchApiOASRequest {
	r.authentication = &authentication
	return r
}

// The content of the file should be the OpenAPI document in JSON format.
func (r ApiPatchApiOASRequest) PatchApiOASRequest(patchApiOASRequest PatchApiOASRequest) ApiPatchApiOASRequest {
	r.patchApiOASRequest = &patchApiOASRequest
	return r
}

func (r ApiPatchApiOASRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.PatchApiOASExecute(r)
}

/*
PatchApiOAS Patch a single OAS API by ID.

Update a Tyk OAS API. You can use this endpoint to update the OAS part of your Tyk OAS API definition. This endpoint allows you to configure the Tyk OAS extension based on the query parameters provided (similar to import).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to patch.
	@return ApiPatchApiOASRequest
*/
func (a *OASAPIsAPIService) PatchApiOAS(ctx context.Context, apiId string) ApiPatchApiOASRequest {
	return ApiPatchApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) PatchApiOASExecute(r ApiPatchApiOASRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.PatchApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upstreamURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "upstreamURL", r.upstreamURL, "form", "")
	}
	if r.listenPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listenPath", r.listenPath, "form", "")
	}
	if r.customDomain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customDomain", r.customDomain, "form", "")
	}
	if r.allowList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowList", r.allowList, "form", "")
	}
	if r.validateRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateRequest", r.validateRequest, "form", "")
	}
	if r.mockResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mockResponse", r.mockResponse, "form", "")
	}
	if r.authentication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "authentication", r.authentication, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchApiOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiCategoriesRequest struct {
	ctx               context.Context
	ApiService        OASAPIsAPI
	apiId             string
	categoriesPayload *CategoriesPayload
}

func (r ApiUpdateApiCategoriesRequest) CategoriesPayload(categoriesPayload CategoriesPayload) ApiUpdateApiCategoriesRequest {
	r.categoriesPayload = &categoriesPayload
	return r
}

func (r ApiUpdateApiCategoriesRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.UpdateApiCategoriesExecute(r)
}

/*
UpdateApiCategories Update OAS API categories.

Update the list of API categories associated with the specified API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API.
	@return ApiUpdateApiCategoriesRequest
*/
func (a *OASAPIsAPIService) UpdateApiCategories(ctx context.Context, apiId string) ApiUpdateApiCategoriesRequest {
	return ApiUpdateApiCategoriesRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) UpdateApiCategoriesExecute(r ApiUpdateApiCategoriesRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.UpdateApiCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}/categories"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.categoriesPayload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateApiOASRequest struct {
	ctx                 context.Context
	ApiService          OASAPIsAPI
	apiId               string
	createApiOASRequest *CreateApiOASRequest
}

func (r ApiUpdateApiOASRequest) CreateApiOASRequest(createApiOASRequest CreateApiOASRequest) ApiUpdateApiOASRequest {
	r.createApiOASRequest = &createApiOASRequest
	return r
}

func (r ApiUpdateApiOASRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.UpdateApiOASExecute(r)
}

/*
UpdateApiOAS Update OAS API.

Updating an API definition uses the same signature object as a `POST`. It will first ensure that the API ID being updated is the same as in the `PUT` object.<br/> Updating will completely replace the file descriptor and will not change an API definition that has already been loaded. The hot-reload endpoint will need to be called to push the new definition to live.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param apiId ID of the API you want to update.
	@return ApiUpdateApiOASRequest
*/
func (a *OASAPIsAPIService) UpdateApiOAS(ctx context.Context, apiId string) ApiUpdateApiOASRequest {
	return ApiUpdateApiOASRequest{
		ApiService: a,
		ctx:        ctx,
		apiId:      apiId,
	}
}

// Execute executes the request
//
//	@return ApiResponse
func (a *OASAPIsAPIService) UpdateApiOASExecute(r ApiUpdateApiOASRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OASAPIsAPIService.UpdateApiOAS")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/oas/{apiId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiId"+"}", url.PathEscape(parameterValueToString(r.apiId, "apiId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createApiOASRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
