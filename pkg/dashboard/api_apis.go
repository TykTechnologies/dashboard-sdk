/*
Tyk Dashboard API

## <a name=\"introduction\"></a> Introduction  The Tyk Dashboard API offers granular, programmatic access to a centralised database of resources that your Tyk nodes can pull from. This API has a dynamic user administrative structure which means the secret key that is used to communicate with your Tyk nodes can be kept secret and access to the wider management functions can be handled on a user-by-user and organisation-by-organisation basis.  A common question around using a database-backed configuration is how to programatically add API definitions to your Tyk nodes, the Dashboard API allows much more fine-grained, secure and multi-user access to your Tyk cluster, and should be used to manage a database-backed Tyk node.  The Tyk Dashboard API works seamlessly with the Tyk Dashboard (and the two come bundled together).  ## <a name=\"security-hierarchy\"></a> Security Hierarchy  The Dashboard API provides a more structured security layer to managing Tyk nodes.  ### Organisations, APIs and Users  With the Dashboard API and a database-backed Tyk setup, (and to an extent with file-based API setups - if diligence is used in naming an creating definitions), the following security model is applied to the management of Upstream APIs:  * **Organisations**: All APIs are *owned* by an organisation, this is designated by the `OrgID` parameter in the API Definition. * **Users**: All users created in the Dashboard belong to an organisation (unless an exception is made for super-administrative access). * **APIs**: All APIs belong to an Organisation and only Users that belong to that organisation can see the analytics for those APIs and manage their configurations. * **API Keys**: API Keys are designated by organisation, this means an API key that has full access rights will not be allowed to access the APIs of another organisation on the same system, but can have full access to all APIs within the organisation. * **Access Rights**: Access rights are stored with the key, this enables a key to give access to multiple APIs, this is defined by the session object in the core Tyk API.  In order to use the Dashboard API, you'll need to get the `Tyk Dashboard API Access Credentials` secret from your user profile on the Dashboard UI.  The secret you set should then be sent along as a header with each Dashboard API Request in order for it to be successful:  ``` authorization: <your-secret> ```

API version: 5.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package dashboard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type APIsAPI interface {

	/*
		DeleteApi Delete a single API by ID

		Delete an API by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of API to get. Can either be internal or public API id.
		@return ApiDeleteApiRequest
	*/
	DeleteApi(ctx context.Context, id string) ApiDeleteApiRequest

	// DeleteApiExecute executes the request
	//  @return ApiStatusMessage
	DeleteApiExecute(r ApiDeleteApiRequest) (*ApiStatusMessage, *http.Response, error)

	/*
		GetAPIExample Get details of a single example API definition

		Get the details of a single API definition, details include full name, location in the repository, description, features and min tyk version

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param location Location of the tyk example in the repository defined in `x-tyk-repo-url`
		@return ApiGetAPIExampleRequest
	*/
	GetAPIExample(ctx context.Context, location string) ApiGetAPIExampleRequest

	// GetAPIExampleExecute executes the request
	//  @return APIExampleDetailed
	GetAPIExampleExecute(r ApiGetAPIExampleRequest) (*APIExampleDetailed, *http.Response, error)

	/*
		GetAPIExamples Get a list of example API definitions

		Returns a list of all example API definitions available in "repository.json" file defined in "x-tyk-examples-index" header. If the header is not provided, Tyk will use the default value of this header which is `tyk-examples` repo as detailed below

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetAPIExamplesRequest
	*/
	GetAPIExamples(ctx context.Context) ApiGetAPIExamplesRequest

	// GetAPIExamplesExecute executes the request
	//  @return GetAPIExamples200Response
	GetAPIExamplesExecute(r ApiGetAPIExamplesRequest) (*GetAPIExamples200Response, *http.Response, error)

	/*
		GetApi Get a single API by ID

		Get an API by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of API to get. Can either be internal or public API id.
		@return ApiGetApiRequest
	*/
	GetApi(ctx context.Context, id string) ApiGetApiRequest

	// GetApiExecute executes the request
	//  @return APIDefinition
	GetApiExecute(r ApiGetApiRequest) (*APIDefinition, *http.Response, error)

	/*
		GetApis Get List of APIs

		Get List of APIs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetApisRequest
	*/
	GetApis(ctx context.Context) ApiGetApisRequest

	// GetApisExecute executes the request
	//  @return []APIDefinition
	GetApisExecute(r ApiGetApisRequest) ([]APIDefinition, *http.Response, error)

	/*
		PostApis Create API Definition

		Create an API Definition. The id and api_id fields in the definition are auto-generated by Tyk and cannot be set by the user.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiPostApisRequest
	*/
	PostApis(ctx context.Context) ApiPostApisRequest

	// PostApisExecute executes the request
	//  @return ApiModifyKeySuccess
	PostApisExecute(r ApiPostApisRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		PutApi Update API Definition

		Update an API Definition. api_id can be updated for On-Premise installations, but it cannot be updated when the Dashboard resides in Tyk Cloud. Updates to api_id in Tyk Cloud will be ignored.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id ID of API to update. Can either be internal or public API id.
		@return ApiPutApiRequest
	*/
	PutApi(ctx context.Context, id string) ApiPutApiRequest

	// PutApiExecute executes the request
	//  @return ApiModifyKeySuccess
	PutApiExecute(r ApiPutApiRequest) (*ApiModifyKeySuccess, *http.Response, error)

	/*
		SearchApis Search List of APIs

		Search List of APIs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSearchApisRequest
	*/
	SearchApis(ctx context.Context) ApiSearchApisRequest

	// SearchApisExecute executes the request
	//  @return []APIDefinition
	SearchApisExecute(r ApiSearchApisRequest) ([]APIDefinition, *http.Response, error)
}

// APIsAPIService APIsAPI service
type APIsAPIService service

type ApiDeleteApiRequest struct {
	ctx        context.Context
	ApiService APIsAPI
	id         string
}

func (r ApiDeleteApiRequest) Execute() (*ApiStatusMessage, *http.Response, error) {
	return r.ApiService.DeleteApiExecute(r)
}

/*
DeleteApi Delete a single API by ID

Delete an API by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of API to get. Can either be internal or public API id.
	@return ApiDeleteApiRequest
*/
func (a *APIsAPIService) DeleteApi(ctx context.Context, id string) ApiDeleteApiRequest {
	return ApiDeleteApiRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ApiStatusMessage
func (a *APIsAPIService) DeleteApiExecute(r ApiDeleteApiRequest) (*ApiStatusMessage, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiStatusMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.DeleteApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAPIExampleRequest struct {
	ctx               context.Context
	ApiService        APIsAPI
	location          string
	xTykRepoUrl       *string
	xTykExamplesIndex *string
	apiDef            *bool
}

// Repository URL to fetch example API definitions from
func (r ApiGetAPIExampleRequest) XTykRepoUrl(xTykRepoUrl string) ApiGetAPIExampleRequest {
	r.xTykRepoUrl = &xTykRepoUrl
	return r
}

// URL path to the \&quot;repository.json\&quot; in the repository defined in &#x60;x-tyk-repo-url&#x60;
func (r ApiGetAPIExampleRequest) XTykExamplesIndex(xTykExamplesIndex string) ApiGetAPIExampleRequest {
	r.xTykExamplesIndex = &xTykExamplesIndex
	return r
}

// If set to true, the response will contain the APIDefinition of the specified example, the definition will be present as the &#x60;apiDefinition&#x60; field.
func (r ApiGetAPIExampleRequest) ApiDef(apiDef bool) ApiGetAPIExampleRequest {
	r.apiDef = &apiDef
	return r
}

func (r ApiGetAPIExampleRequest) Execute() (*APIExampleDetailed, *http.Response, error) {
	return r.ApiService.GetAPIExampleExecute(r)
}

/*
GetAPIExample Get details of a single example API definition

Get the details of a single API definition, details include full name, location in the repository, description, features and min tyk version

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param location Location of the tyk example in the repository defined in `x-tyk-repo-url`
	@return ApiGetAPIExampleRequest
*/
func (a *APIsAPIService) GetAPIExample(ctx context.Context, location string) ApiGetAPIExampleRequest {
	return ApiGetAPIExampleRequest{
		ApiService: a,
		ctx:        ctx,
		location:   location,
	}
}

// Execute executes the request
//
//	@return APIExampleDetailed
func (a *APIsAPIService) GetAPIExampleExecute(r ApiGetAPIExampleRequest) (*APIExampleDetailed, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *APIExampleDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.GetAPIExample")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/examples/{location}"
	localVarPath = strings.Replace(localVarPath, "{"+"location"+"}", url.PathEscape(parameterValueToString(r.location, "location")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.apiDef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apiDef", r.apiDef, "")
	} else {
		var defaultValue bool = false
		r.apiDef = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTykRepoUrl != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tyk-repo-url", r.xTykRepoUrl, "")
	}
	if r.xTykExamplesIndex != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tyk-examples-index", r.xTykExamplesIndex, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAPIExamplesRequest struct {
	ctx               context.Context
	ApiService        APIsAPI
	p                 *int32
	xTykExamplesIndex *string
}

// Page number. If not provided, the first page will be returned
func (r ApiGetAPIExamplesRequest) P(p int32) ApiGetAPIExamplesRequest {
	r.p = &p
	return r
}

// URL that points to the index file (repository.json) or root of a repository housing examples.
func (r ApiGetAPIExamplesRequest) XTykExamplesIndex(xTykExamplesIndex string) ApiGetAPIExamplesRequest {
	r.xTykExamplesIndex = &xTykExamplesIndex
	return r
}

func (r ApiGetAPIExamplesRequest) Execute() (*GetAPIExamples200Response, *http.Response, error) {
	return r.ApiService.GetAPIExamplesExecute(r)
}

/*
GetAPIExamples Get a list of example API definitions

Returns a list of all example API definitions available in "repository.json" file defined in "x-tyk-examples-index" header. If the header is not provided, Tyk will use the default value of this header which is `tyk-examples` repo as detailed below

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAPIExamplesRequest
*/
func (a *APIsAPIService) GetAPIExamples(ctx context.Context) ApiGetAPIExamplesRequest {
	return ApiGetAPIExamplesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetAPIExamples200Response
func (a *APIsAPIService) GetAPIExamplesExecute(r ApiGetAPIExamplesRequest) (*GetAPIExamples200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAPIExamples200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.GetAPIExamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/examples"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.p != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "p", r.p, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xTykExamplesIndex != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-tyk-examples-index", r.xTykExamplesIndex, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiRequest struct {
	ctx        context.Context
	ApiService APIsAPI
	id         string
}

func (r ApiGetApiRequest) Execute() (*APIDefinition, *http.Response, error) {
	return r.ApiService.GetApiExecute(r)
}

/*
GetApi Get a single API by ID

Get an API by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of API to get. Can either be internal or public API id.
	@return ApiGetApiRequest
*/
func (a *APIsAPIService) GetApi(ctx context.Context, id string) ApiGetApiRequest {
	return ApiGetApiRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return APIDefinition
func (a *APIsAPIService) GetApiExecute(r ApiGetApiRequest) (*APIDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *APIDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.GetApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApisRequest struct {
	ctx        context.Context
	ApiService APIsAPI
	compressed *string
	graph      *string
	apiType    *string
	q          *string
	sort       *string
	category   *string
	authType   *string
	baseApis   *string
}

// Return smaller API list payload.
// Deprecated
func (r ApiGetApisRequest) Compressed(compressed string) ApiGetApisRequest {
	r.compressed = &compressed
	return r
}

// Transform the response payload for graphql.
// Deprecated
func (r ApiGetApisRequest) Graph(graph string) ApiGetApisRequest {
	r.graph = &graph
	return r
}

// API Type, internal or external.
func (r ApiGetApisRequest) ApiType(apiType string) ApiGetApisRequest {
	r.apiType = &apiType
	return r
}

// Query string for search/filtering.
func (r ApiGetApisRequest) Q(q string) ApiGetApisRequest {
	r.q = &q
	return r
}

// Sorting criteria.
func (r ApiGetApisRequest) Sort(sort string) ApiGetApisRequest {
	r.sort = &sort
	return r
}

// Filter APIs by category (CSV).
func (r ApiGetApisRequest) Category(category string) ApiGetApisRequest {
	r.category = &category
	return r
}

// Filter APIs by authentication type (CSV).
func (r ApiGetApisRequest) AuthType(authType string) ApiGetApisRequest {
	r.authType = &authType
	return r
}

// For versioned APIs, return only the base versions.
func (r ApiGetApisRequest) BaseApis(baseApis string) ApiGetApisRequest {
	r.baseApis = &baseApis
	return r
}

func (r ApiGetApisRequest) Execute() ([]APIDefinition, *http.Response, error) {
	return r.ApiService.GetApisExecute(r)
}

/*
GetApis Get List of APIs

Get List of APIs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetApisRequest
*/
func (a *APIsAPIService) GetApis(ctx context.Context) ApiGetApisRequest {
	return ApiGetApisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []APIDefinition
func (a *APIsAPIService) GetApisExecute(r ApiGetApisRequest) ([]APIDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []APIDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.GetApis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.compressed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compressed", r.compressed, "")
	}
	if r.graph != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "graph", r.graph, "")
	}
	if r.apiType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "api_type", r.apiType, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.authType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_type", r.authType, "")
	}
	if r.baseApis != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_apis", r.baseApis, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostApisRequest struct {
	ctx                context.Context
	ApiService         APIsAPI
	baseApiId          *string
	baseApiVersionName *string
	newVersionName     *string
	setDefault         *bool
	aPIDefinition      *APIDefinition
}

// The base API which the new version will be linked to.
func (r ApiPostApisRequest) BaseApiId(baseApiId string) ApiPostApisRequest {
	r.baseApiId = &baseApiId
	return r
}

// The version name of the base API while creating the first version. This doesn&#39;t have to be sent for the next versions but if it is set, it will override base API version name.
func (r ApiPostApisRequest) BaseApiVersionName(baseApiVersionName string) ApiPostApisRequest {
	r.baseApiVersionName = &baseApiVersionName
	return r
}

// The version name of the created version.
func (r ApiPostApisRequest) NewVersionName(newVersionName string) ApiPostApisRequest {
	r.newVersionName = &newVersionName
	return r
}

// If true, the new version is set as default version.
func (r ApiPostApisRequest) SetDefault(setDefault bool) ApiPostApisRequest {
	r.setDefault = &setDefault
	return r
}

func (r ApiPostApisRequest) APIDefinition(aPIDefinition APIDefinition) ApiPostApisRequest {
	r.aPIDefinition = &aPIDefinition
	return r
}

func (r ApiPostApisRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.PostApisExecute(r)
}

/*
PostApis Create API Definition

Create an API Definition. The id and api_id fields in the definition are auto-generated by Tyk and cannot be set by the user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostApisRequest
*/
func (a *APIsAPIService) PostApis(ctx context.Context) ApiPostApisRequest {
	return ApiPostApisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *APIsAPIService) PostApisExecute(r ApiPostApisRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.PostApis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseApiId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_id", r.baseApiId, "")
	}
	if r.baseApiVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_api_version_name", r.baseApiVersionName, "")
	}
	if r.newVersionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_version_name", r.newVersionName, "")
	}
	if r.setDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_default", r.setDefault, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aPIDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutApiRequest struct {
	ctx           context.Context
	ApiService    APIsAPI
	id            string
	aPIDefinition *APIDefinition
}

func (r ApiPutApiRequest) APIDefinition(aPIDefinition APIDefinition) ApiPutApiRequest {
	r.aPIDefinition = &aPIDefinition
	return r
}

func (r ApiPutApiRequest) Execute() (*ApiModifyKeySuccess, *http.Response, error) {
	return r.ApiService.PutApiExecute(r)
}

/*
PutApi Update API Definition

Update an API Definition. api_id can be updated for On-Premise installations, but it cannot be updated when the Dashboard resides in Tyk Cloud. Updates to api_id in Tyk Cloud will be ignored.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of API to update. Can either be internal or public API id.
	@return ApiPutApiRequest
*/
func (a *APIsAPIService) PutApi(ctx context.Context, id string) ApiPutApiRequest {
	return ApiPutApiRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return ApiModifyKeySuccess
func (a *APIsAPIService) PutApiExecute(r ApiPutApiRequest) (*ApiModifyKeySuccess, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ApiModifyKeySuccess
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.PutApi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aPIDefinition
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiStatusMessage
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchApisRequest struct {
	ctx        context.Context
	ApiService APIsAPI
	q          *string
}

// Search query
func (r ApiSearchApisRequest) Q(q string) ApiSearchApisRequest {
	r.q = &q
	return r
}

func (r ApiSearchApisRequest) Execute() ([]APIDefinition, *http.Response, error) {
	return r.ApiService.SearchApisExecute(r)
}

/*
SearchApis Search List of APIs

Search List of APIs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchApisRequest
*/
func (a *APIsAPIService) SearchApis(ctx context.Context) ApiSearchApisRequest {
	return ApiSearchApisRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []APIDefinition
func (a *APIsAPIService) SearchApisExecute(r ApiSearchApisRequest) ([]APIDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []APIDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIsAPIService.SearchApis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/apis/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
